# Module 6 - Exercise 1: Creating a Data Warehouse
From the Operational Model to the Dimensional Model

- Name: Caleb Sellinger
- Course: Database for Analytics
- Module: 6

---

## Overview

In this exercise you will design a **dimensional (star schema) model** for a data warehouse based on an **operational sales database**.

- **Business process:** Customer Sales
- **Grain:** Daily sales
- **Facts to store (only):**
  - **amount** = daily sales total amount (revenue)
  - **quantity** = daily sales total quantity (units sold)

You will determine the dimensions needed to support the required analytics.

---

## Operational Database Summary (Source System)

Tables in the operational model include:

- `customer` (custNumber, custName, address, currBal, credLimit, repNum)
- `parts` (partNum, partDesc, category, unitsOnHand, warehouseNum, unitPrice)
- `slsrep` (repNum, repName, repAddress, totComm, commRate)
- `orders` (orderNum, orderDate, custNum)
- `orderline` (orderNum, partNum, numOrdered)

---

## Analytics Requirements (What the Warehouse Must Support)

Your dimensional model must support questions such as:

- How many of part number **ax12** were sold on **September 2, 1994**?
- How many of part number **ax12** did customer **124** purchase last year?
- How much did customer **124** spend last year?
- What was the **average amount spent per customer per day** during September 1994?
- What was the **average quantity sold of part ax12 per day** during September 1994?
- What was the **average daily sales** during the third quarter of 1994?
- How many **appliance** items were sold during the third quarter of 1994?
- What was the amount of revenue generated by customers in **zip code 64468** during September 1994?

---

## Non-Requirements (Do Not Design For These)

We do **not** care about:

- Questions about **specific orders** (order-level reporting)
- Questions about **sales reps**
- Questions about **credit limits, balances**, or other customer finance fields
- Inventory questions (warehouseNum, unitsOnHand, etc.)

---

## Key Design Constraints

- The warehouse must be a **star schema**.
- The fact table must store only:
  - `amount`
  - `quantity`
- Data must be **aggregated as necessary from the operational database before loading**.
- The grain is **daily sales** (not per order, not per orderline).

---

## Your Task

### Step 1: Design the Star Schema

Create a dimensional model that includes:

- One **fact table** (daily customer sales facts)
- Appropriate **dimension tables** (you decide which ones are necessary)

Your model must clearly show:

- Fact table name and fields
- Dimension table names and fields
- Primary keys and foreign keys
- Relationships (dimensions connect to the fact table)

---

## Deliverables

### 1) Star Schema Diagram (Required)

Create and submit a **diagram** of your star schema.

You may use any tool, such as:
- draw.io (diagrams.net)
- PowerPoint
- Google Drawings
- Lucidchart
- Hand-drawn on paper (then take a clear photo)

Save your diagram image in this repo and embed it below.

**File name suggestion:** `star-schema.png` or `star-schema.jpg`

#### Diagram

![alt text](screenshots/star-schema.png)

---

### 2) Design Notes (Required)

In 1-2 short paragraphs, explain:

- What dimensions you chose and why
- Why your fact table grain is daily sales
- How your design supports at least 3 of the required analytics questions

#### Design Notes

The fact table's quantitative data can be filed down to the primary keys on a per customer, per part, per order basis making the grain based on daily sales, as you cannot make one order on two different days. In this way, we can see daily sales by customer, part, or date. The grain cannot be reduced as the date is only modified by day. There is no reference to time of day, such as noon or midnight. The amounts and quantities would be calculated by the following (using the operational database):

```sql
SELECT
      c.custNumber,
      p.partNum,
      o.orderNum,
      o.orderDate,
      ol.numOrdered as quantity,
      SUM(p.unitPrice) as amount
FROM parts as p
JOIN orderline as ol
ON ol.partNum = p.partNum
JOIN orders as o
ON o.orderNum = ol.orderNum
JOIN customer as c
ON c.custNumber = o.custNum
GROUP BY c.custNumber, p.partNum, o.orderNum, o.orderDate;
```

The customer table contains customer name and zipcode (extracted from customer.address using postgresql's substring function) to answer two defined questions, **average amount spent per customer per day** and **amount of revenue generated by customers in zip code**.

```sql
-- Average amount spent per customer per day
SELECT orderDate, custNum, AVG(amount)
FROM ft_daily_sales
GROUP BY custNum, orderDate
ORDER BY custNum ASC;
```

```sql
-- Amount of revenue generated by customers in specific zipcode
SELECT c.zipcode, SUM(f.amount)
FROM ft_daily_sales f
JOIN dm_customers c ON c.custNum = f.custNum
GROUP BY c.zipcode
```

The parts table contains category and unit price to answer **How many appliance items were sold during [date]** or any other part related queries.

```sql
SELECT f.orderDate, p.category, COUNT(f.partNum)
FROM ft_daily_sales f
JOIN dm_parts p
ON p.partNum = f.partNum
WHERE p.category = 'Appliance' AND f.orderDate = [date]
GROUP BY p.category, f.orderDate
```

The date table contains full date and extracts for day, month, year, in order to reduce grain to daily aggregations.
